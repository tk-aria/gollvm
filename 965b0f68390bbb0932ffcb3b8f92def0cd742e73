{
  "comments": [
    {
      "key": {
        "uuid": "fade72c7_91cb1335",
        "filename": "bridge/go-llvm.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2585,
      "author": {
        "id": 13315
      },
      "writtenOn": "2019-06-04T15:54:58Z",
      "side": 1,
      "message": "I think before there was no function that is both visible and only_inline (see also https://go.googlesource.com/gollvm/+/c08b8899001e26a9b58d72082b03ac343bb445e3/unittests/BackendCore/BackendFcnTests.cpp#91). Now there are? What changed? It appears that the new code assumes only_inline functions are always visible, which is the opposite of what it was.\n\nMaybe we could set only_inline function as AvailableExternallyLinkage regardless of visibility?\n\nDoes the test case need adjustment?",
      "revId": "965b0f68390bbb0932ffcb3b8f92def0cd742e73",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b70c8622_2006d407",
        "filename": "bridge/go-llvm.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2585,
      "author": {
        "id": 14020
      },
      "writtenOn": "2019-06-04T16:23:05Z",
      "side": 1,
      "message": "Hmm. You are right, the unit test disagrees with this change. \n\nThere were a number of functions that were triggering the problem; two examples were sync.RWMutex.RLocker and time.Duration.Nanoseconds. Let me poke around a little to gather some data to see what has changed.",
      "parentUuid": "fade72c7_91cb1335",
      "revId": "965b0f68390bbb0932ffcb3b8f92def0cd742e73",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c1f81b11_ac221b3c",
        "filename": "bridge/go-llvm.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2585,
      "author": {
        "id": 14020
      },
      "writtenOn": "2019-06-04T17:55:13Z",
      "side": 1,
      "message": "OK, I added some tracing code and tried things before and after Ian\u0027s recent inlining change. Before the change, all the only_inline\u003dtrue functions were marked as non-visible (which doesn\u0027t seem right). Now all only_inline\u003dtrue functions are being marked as visible.\n\nRegarding marking all only_inline\u003dtrue functions as available externally -- that seems like it would work, but I wonder if it might get us into hot water later on. Example:\n\n package p1\n func InlineMe() {\n   local()\n   ...\n }\n func local() { ... }\n\n----\n\n package p2\n import \"p1\"\n func P2Func() {\n   p1.InlineMe()\n }\n\n----\n\nDuring compilation of package p1, the front end exports bodies for both p1.InlineMe() and p1.local() since they are both small enough, both would be marked as \"only_inline\u003dtrue\".  Presumably the exported version of p1.local would have to be be marked as non-visible (so as to prevent calls from other packages).\n\nIn the backend phase for compiling p1, let\u0027s say all p1.local call sites are inlined, so the out-of-line definition of p1.local is deleted.\n\nNow we compile p2.  We can\u0027t guarantee that all calls to p1.local are inlined away (maybe the file is huge and the back end runs out of inline budget). In that scenario we can\u0027t mark p1.local AvailableExternally since it is in fact not really available. \n\nSo I think the way I have it in the current patch is the way to go. I will adjust the unit test, however.",
      "parentUuid": "b70c8622_2006d407",
      "revId": "965b0f68390bbb0932ffcb3b8f92def0cd742e73",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8b063227_47b3fd68",
        "filename": "bridge/go-llvm.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2585,
      "author": {
        "id": 13315
      },
      "writtenOn": "2019-06-04T21:09:43Z",
      "side": 1,
      "message": "Emmm. I\u0027m not sure what is the exact meaning of \"visible\" for only_inline functions.\n\nI think only_inline is used only for imported functions. So when compiling p1, \"local\" would not be marked as only_inline. I would think it will be marked visible if its body is exported for inlining. The frontend will reject calls from other package to p1.local directly. (It is true that it won\u0027t be able to stop non-Go code call that function.)\n\nIf this is the case, when compiling p2 it will not emit a standalone copy of p1.local, even if it is not inlined, as it is actually externally available (in p1). And it does not matter whether it is visible.",
      "parentUuid": "c1f81b11_ac221b3c",
      "revId": "965b0f68390bbb0932ffcb3b8f92def0cd742e73",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "605a59aa_d4c552ea",
        "filename": "bridge/go-llvm.cpp",
        "patchSetId": 3
      },
      "lineNbr": 2585,
      "author": {
        "id": 14020
      },
      "writtenOn": "2019-06-05T13:58:10Z",
      "side": 1,
      "message": "OK.  In that case I think what we need is an assert that fires if we see an only_inline function that is not marked visible. I think that should protect from the scenario I was concerned about.",
      "parentUuid": "8b063227_47b3fd68",
      "revId": "965b0f68390bbb0932ffcb3b8f92def0cd742e73",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}