{
  "comments": [
    {
      "key": {
        "uuid": "fa9fe130_cabacbcd",
        "filename": "bridge/go-llvm-materialize.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1385,
      "author": {
        "id": 14020
      },
      "writtenOn": "2020-05-07T11:16:39Z",
      "side": 1,
      "message": "I think a better way to do this would be to check the target at runtime, as opposed to doing conditional compilation with #ifdef (this is more in the spirit of how LLVM handles these things).",
      "revId": "189873d6b0351f0c1315472944ce139679143194",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8727aee5_49518f79",
        "filename": "bridge/go-llvm-materialize.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1385,
      "author": {
        "id": 24534
      },
      "writtenOn": "2020-05-13T01:48:07Z",
      "side": 1,
      "message": "You mean defining getg implementation of different architectures with #ifdef at the definition of getg function? That may not work, because getg is an external symbol in go files. Even if we remove the noinline attribute of getg and add the volatile attribute to the inline assembly, without makeGetg function, getg won\u0027t be inlined. And if we just turn the getg function call into a load of g in the makeGetg function, the global cse will still work on arm64. So we turn the getg function call to inline assembly node here.\n\nBut we can check the target here, done.",
      "parentUuid": "fa9fe130_cabacbcd",
      "revId": "189873d6b0351f0c1315472944ce139679143194",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3058ff3d_f5f698ad",
        "filename": "bridge/go-llvm-materialize.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1385,
      "author": {
        "id": 14020
      },
      "writtenOn": "2020-05-13T11:46:41Z",
      "side": 1,
      "message": "Sorry, I wasn\u0027t clear about my intent.\n\nWhat I had in mind was using a C++ \"if\" statement as opposed to #ifdef, so that if gollvm targets N different architectures, we can have a single llvm-goc binary as opposed to N target-specific binaries. That single binary would then emit code for the correct arch based on the target setting.\n\nSo makeGetgArm64 would always be compiled in, but down below in makeGetg, the code would look something like\n\n  if (be-\u003egetTargetTriple().getArch() \u003d\u003d llvm::Triple::aarch64) {\n    return makeGetgArm64(resType, builder, be);\n  } else {\n    return builder-\u003eCreateLoad(g);\n  }\n\ninstead of using the #ifdef equivalent. Doing this may require some plumbing work to pass the target triple into the bridge (probably pass target triple into Llvm_backend() constructor).",
      "parentUuid": "8727aee5_49518f79",
      "revId": "189873d6b0351f0c1315472944ce139679143194",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    }
  ]
}