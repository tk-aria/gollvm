{
  "comments": [
    {
      "key": {
        "uuid": "4abbb5c6_844336fd",
        "filename": "driver/Driver.cpp",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 5206
      },
      "writtenOn": "2018-05-29T17:36:33Z",
      "side": 1,
      "message": "I suppose eventually we may want to distinguish -fPIC and -fPIE.",
      "revId": "2240bacc3a8cab9cdc32d5a64100d7b05f5e105f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "41a8ef48_b8ab9502",
        "filename": "driver/Driver.cpp",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 14020
      },
      "writtenOn": "2018-05-29T17:57:23Z",
      "side": 1,
      "message": "I agree, although at the moment from what I can see from inspecting the clang sources (assuming I read them correctly), -fPIC and -fPIE are treated identically in terms of how the LLVM back end is configured and executed. Obviously for C++ compilers there is a distinction in that they each define a different preprocessor symbol, but for Go that doesn\u0027t seem like an issue.\n\nAre you aware of cases/scenarios where -fPIC and -fPIE would result in different code coming out of the compiler?  Mainly asking out of curiosity.",
      "parentUuid": "4abbb5c6_844336fd",
      "revId": "2240bacc3a8cab9cdc32d5a64100d7b05f5e105f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e6f4a1ca_197c3411",
        "filename": "driver/Driver.cpp",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 5206
      },
      "writtenOn": "2018-05-29T19:26:33Z",
      "side": 1,
      "message": "I don\u0027t know what the LLVM backend does, but normally -fPIE will use a shorter instruction sequence when referring to a locally defined variable.  Compare\n\nint a;\nint f() { return a; }\n\ncompiled with -fPIC and -fPIE.  With -fPIC GCC will generate\n\tmovq\ta@GOTPCREL(%rip), %rax\n\tmovl\t(%rax), %eax\nand with -fPIE it will generate\n\tmovl\ta(%rip), %eax\n\nBasically with -fPIE we know that there can\u0027t be any interposition on the variable, so we don\u0027t have to go through the GOT.",
      "parentUuid": "41a8ef48_b8ab9502",
      "revId": "2240bacc3a8cab9cdc32d5a64100d7b05f5e105f",
      "serverId": "62eb7196-b449-3ce5-99f1-c037f21e1705",
      "unresolved": false
    }
  ]
}